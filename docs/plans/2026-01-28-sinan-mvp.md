# 司南 (Sinan) MVP 实现计划

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** 实现「对话生成用例 → 执行 → 画布可视化」的 MVP 核心流程

**Architecture:** 采用 Electron + React 前端 + Python FastAPI 后端的混合架构。前端负责 UI 展示和用户交互，Python 后端负责设备驱动、AI 推理和用例执行。通过 WebSocket 实现实时通信。

**Tech Stack:** Electron 30, React 18, TypeScript, Vite 5, Python 3.12, FastAPI, WebSocket, ADB/HDC

---

## 阶段一：设备驱动层 (Week 1-2)

### Task 1: Python 项目结构重构

**Files:**
- Create: `sinan-core/src/sinan_core/__init__.py`
- Create: `sinan-core/src/sinan_core/drivers/__init__.py`
- Create: `sinan-core/src/sinan_core/api/__init__.py`
- Modify: `sinan-core/pyproject.toml`

**Step 1: 创建 src 目录结构**

```bash
mkdir -p sinan-core/src/sinan_core/drivers
mkdir -p sinan-core/src/sinan_core/api
mkdir -p sinan-core/src/sinan_core/agents
mkdir -p sinan-core/tests
```

**Step 2: 创建 __init__.py 文件**

```bash
touch sinan-core/src/sinan_core/__init__.py
touch sinan-core/src/sinan_core/drivers/__init__.py
touch sinan-core/src/sinan_core/api/__init__.py
touch sinan-core/src/sinan_core/agents/__init__.py
```

**Step 3: 更新 pyproject.toml 添加包配置**

在 pyproject.toml 中添加：
```toml
[tool.setuptools.packages.find]
where = ["src"]

[tool.pytest.ini_options]
testpaths = ["tests"]
pythonpath = ["src"]
```

**Step 4: 验证项目结构**

Run: `cd sinan-core && uv sync && uv run python -c "import sinan_core; print('OK')"`
Expected: OK

**Step 5: Commit**

```bash
git add sinan-core/
git commit -m "refactor: 重构 Python 项目结构为 src layout"
```

---

### Task 2: 设备驱动抽象基类

**Files:**
- Create: `sinan-core/src/sinan_core/drivers/base.py`
- Create: `sinan-core/tests/test_drivers_base.py`

**Step 1: 编写基类测试**

```python
# sinan-core/tests/test_drivers_base.py
import pytest
from sinan_core.drivers.base import BaseDevice

def test_base_device_is_abstract():
    """BaseDevice 不能直接实例化"""
    with pytest.raises(TypeError):
        BaseDevice()

def test_base_device_has_required_methods():
    """BaseDevice 定义了所有必需的抽象方法"""
    required_methods = ['tap', 'swipe', 'screenshot', 'get_ui_tree', 'input_text', 'connect', 'disconnect']
    for method in required_methods:
        assert hasattr(BaseDevice, method)
```

**Step 2: 运行测试验证失败**

Run: `cd sinan-core && uv run pytest tests/test_drivers_base.py -v`
Expected: FAIL (ModuleNotFoundError)

**Step 3: 实现 BaseDevice 抽象基类**

```python
# sinan-core/src/sinan_core/drivers/base.py
"""设备驱动抽象基类"""
from abc import ABC, abstractmethod
from PIL import Image

class BaseDevice(ABC):
    """设备驱动抽象基类，定义统一的设备操作接口"""
    
    @abstractmethod
    def connect(self) -> bool:
        """连接设备，返回是否成功"""
        pass
    
    @abstractmethod
    def disconnect(self) -> None:
        """断开设备连接"""
        pass
    
    @abstractmethod
    def tap(self, x: int, y: int) -> bool:
        """点击指定坐标"""
        pass
    
    @abstractmethod
    def swipe(self, x1: int, y1: int, x2: int, y2: int, duration_ms: int = 300) -> bool:
        """滑动操作"""
        pass
    
    @abstractmethod
    def screenshot(self) -> Image.Image:
        """截取屏幕，返回 PIL Image"""
        pass
    
    @abstractmethod
    def get_ui_tree(self) -> dict:
        """获取 UI 树结构"""
        pass
    
    @abstractmethod
    def input_text(self, text: str) -> bool:
        """输入文本"""
        pass
```

**Step 4: 运行测试验证通过**

Run: `cd sinan-core && uv run pytest tests/test_drivers_base.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add sinan-core/src/sinan_core/drivers/base.py sinan-core/tests/test_drivers_base.py
git commit -m "feat: 添加设备驱动抽象基类 BaseDevice"
```

---

### Task 3: Android 设备驱动实现

**Files:**
- Create: `sinan-core/src/sinan_core/drivers/android.py`
- Create: `sinan-core/tests/test_drivers_android.py`
- Modify: `sinan-core/pyproject.toml` (添加 adb 依赖)

**Step 1: 添加 adb 依赖**

Run: `cd sinan-core && uv add adb-shell`

**Step 2: 编写 Android 驱动测试**

```python
# sinan-core/tests/test_drivers_android.py
import pytest
from unittest.mock import Mock, patch
from sinan_core.drivers.android import AndroidDevice
from sinan_core.drivers.base import BaseDevice

def test_android_device_inherits_base():
    """AndroidDevice 继承自 BaseDevice"""
    assert issubclass(AndroidDevice, BaseDevice)

def test_android_device_init():
    """AndroidDevice 初始化需要设备序列号"""
    device = AndroidDevice(serial="emulator-5554")
    assert device.serial == "emulator-5554"

@patch('sinan_core.drivers.android.AdbDeviceTcp')
def test_android_device_connect(mock_adb):
    """测试设备连接"""
    mock_adb_instance = Mock()
    mock_adb.return_value = mock_adb_instance
    mock_adb_instance.connect.return_value = True
    
    device = AndroidDevice(serial="127.0.0.1:5555")
    result = device.connect()
    
    assert result is True
```

**Step 3: 运行测试验证失败**

Run: `cd sinan-core && uv run pytest tests/test_drivers_android.py -v`
Expected: FAIL

**Step 4: 实现 AndroidDevice**

```python
# sinan-core/src/sinan_core/drivers/android.py
"""Android 设备驱动实现"""
import subprocess
import tempfile
from pathlib import Path
from PIL import Image
from .base import BaseDevice

class AndroidDevice(BaseDevice):
    """Android 设备驱动，基于 ADB 实现"""
    
    def __init__(self, serial: str):
        self.serial = serial
        self._connected = False
    
    def _adb(self, *args: str) -> subprocess.CompletedProcess:
        """执行 adb 命令"""
        cmd = ["adb", "-s", self.serial] + list(args)
        return subprocess.run(cmd, capture_output=True, text=True)
    
    def connect(self) -> bool:
        """连接设备"""
        result = self._adb("get-state")
        self._connected = result.returncode == 0
        return self._connected
    
    def disconnect(self) -> None:
        """断开连接"""
        self._connected = False
    
    def tap(self, x: int, y: int) -> bool:
        """点击坐标"""
        result = self._adb("shell", "input", "tap", str(x), str(y))
        return result.returncode == 0
    
    def swipe(self, x1: int, y1: int, x2: int, y2: int, duration_ms: int = 300) -> bool:
        """滑动操作"""
        result = self._adb("shell", "input", "swipe", 
                          str(x1), str(y1), str(x2), str(y2), str(duration_ms))
        return result.returncode == 0
    
    def screenshot(self) -> Image.Image:
        """截取屏幕"""
        with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as f:
            temp_path = f.name
        
        self._adb("exec-out", "screencap", "-p", ">", temp_path)
        # 使用 pull 方式更可靠
        self._adb("shell", "screencap", "-p", "/sdcard/screen.png")
        self._adb("pull", "/sdcard/screen.png", temp_path)
        
        img = Image.open(temp_path)
        Path(temp_path).unlink()
        return img
    
    def get_ui_tree(self) -> dict:
        """获取 UI 树"""
        self._adb("shell", "uiautomator", "dump", "/sdcard/ui.xml")
        result = self._adb("shell", "cat", "/sdcard/ui.xml")
        # TODO: 解析 XML 为 dict
        return {"raw_xml": result.stdout}
    
    def input_text(self, text: str) -> bool:
        """输入文本"""
        # 转义特殊字符
        escaped = text.replace(" ", "%s").replace("'", "\\'")
        result = self._adb("shell", "input", "text", escaped)
        return result.returncode == 0
```

**Step 5: 运行测试验证通过**

Run: `cd sinan-core && uv run pytest tests/test_drivers_android.py -v`
Expected: PASS

**Step 6: Commit**

```bash
git add sinan-core/
git commit -m "feat: 实现 Android 设备驱动 AndroidDevice"
```

---

### Task 4: 鸿蒙设备驱动实现

**Files:**
- Create: `sinan-core/src/sinan_core/drivers/harmony.py`
- Create: `sinan-core/tests/test_drivers_harmony.py`

**Step 1: 编写鸿蒙驱动测试**

```python
# sinan-core/tests/test_drivers_harmony.py
import pytest
from unittest.mock import Mock, patch
from sinan_core.drivers.harmony import HarmonyDevice
from sinan_core.drivers.base import BaseDevice

def test_harmony_device_inherits_base():
    """HarmonyDevice 继承自 BaseDevice"""
    assert issubclass(HarmonyDevice, BaseDevice)

def test_harmony_device_init():
    """HarmonyDevice 初始化需要设备序列号"""
    device = HarmonyDevice(serial="FMR0223C13000649")
    assert device.serial == "FMR0223C13000649"

@patch('subprocess.run')
def test_harmony_device_connect(mock_run):
    """测试设备连接"""
    mock_run.return_value = Mock(returncode=0, stdout="device")
    
    device = HarmonyDevice(serial="FMR0223C13000649")
    result = device.connect()
    
    assert result is True
```

**Step 2: 运行测试验证失败**

Run: `cd sinan-core && uv run pytest tests/test_drivers_harmony.py -v`
Expected: FAIL

**Step 3: 实现 HarmonyDevice**

```python
# sinan-core/src/sinan_core/drivers/harmony.py
"""鸿蒙 Next 设备驱动实现"""
import subprocess
import tempfile
import json
from pathlib import Path
from PIL import Image
from .base import BaseDevice

class HarmonyDevice(BaseDevice):
    """鸿蒙设备驱动，基于 HDC 实现"""
    
    def __init__(self, serial: str):
        self.serial = serial
        self._connected = False
    
    def _hdc(self, *args: str) -> subprocess.CompletedProcess:
        """执行 hdc 命令"""
        cmd = ["hdc", "-t", self.serial] + list(args)
        return subprocess.run(cmd, capture_output=True, text=True)
    
    def connect(self) -> bool:
        """连接设备"""
        result = self._hdc("shell", "echo", "ok")
        self._connected = result.returncode == 0 and "ok" in result.stdout
        return self._connected
    
    def disconnect(self) -> None:
        """断开连接"""
        self._connected = False
    
    def tap(self, x: int, y: int) -> bool:
        """点击坐标 - 使用 uitest"""
        result = self._hdc("shell", "uitest", "uiInput", "click", str(x), str(y))
        return result.returncode == 0
    
    def swipe(self, x1: int, y1: int, x2: int, y2: int, duration_ms: int = 300) -> bool:
        """滑动操作"""
        result = self._hdc("shell", "uitest", "uiInput", "swipe", 
                          str(x1), str(y1), str(x2), str(y2), str(duration_ms))
        return result.returncode == 0
    
    def screenshot(self) -> Image.Image:
        """截取屏幕"""
        with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as f:
            temp_path = f.name
        
        remote_path = "/data/local/tmp/screen.png"
        self._hdc("shell", "snapshot_display", "-f", remote_path)
        self._hdc("file", "recv", remote_path, temp_path)
        
        img = Image.open(temp_path)
        Path(temp_path).unlink()
        return img
    
    def get_ui_tree(self) -> dict:
        """获取 UI 树 - 使用 uitest dumpLayout"""
        remote_path = "/data/local/tmp/layout.json"
        self._hdc("shell", "uitest", "dumpLayout", "-p", remote_path)
        result = self._hdc("shell", "cat", remote_path)
        
        try:
            return json.loads(result.stdout)
        except json.JSONDecodeError:
            return {"raw": result.stdout}
    
    def input_text(self, text: str) -> bool:
        """输入文本"""
        result = self._hdc("shell", "uitest", "uiInput", "inputText", text)
        return result.returncode == 0
```

**Step 4: 运行测试验证通过**

Run: `cd sinan-core && uv run pytest tests/test_drivers_harmony.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add sinan-core/
git commit -m "feat: 实现鸿蒙设备驱动 HarmonyDevice"
```

---

### Task 5: 设备管理器

**Files:**
- Create: `sinan-core/src/sinan_core/drivers/manager.py`
- Create: `sinan-core/tests/test_device_manager.py`

**Step 1: 编写设备管理器测试**

```python
# sinan-core/tests/test_device_manager.py
import pytest
from unittest.mock import Mock, patch
from sinan_core.drivers.manager import DeviceManager

def test_device_manager_list_devices():
    """测试列出所有设备"""
    manager = DeviceManager()
    devices = manager.list_devices()
    assert isinstance(devices, list)

def test_device_manager_get_device():
    """测试获取指定设备"""
    manager = DeviceManager()
    # 模拟设备
    with patch.object(manager, '_detect_device_type', return_value='android'):
        device = manager.get_device("emulator-5554")
        assert device is not None
```

**Step 2: 运行测试验证失败**

Run: `cd sinan-core && uv run pytest tests/test_device_manager.py -v`
Expected: FAIL

**Step 3: 实现 DeviceManager**

```python
# sinan-core/src/sinan_core/drivers/manager.py
"""设备管理器"""
import subprocess
from typing import Optional
from .base import BaseDevice
from .android import AndroidDevice
from .harmony import HarmonyDevice

class DeviceManager:
    """设备管理器，负责设备发现和管理"""
    
    def __init__(self):
        self._devices: dict[str, BaseDevice] = {}
    
    def list_devices(self) -> list[dict]:
        """列出所有可用设备"""
        devices = []
        
        # 检测 Android 设备
        try:
            result = subprocess.run(["adb", "devices"], capture_output=True, text=True)
            for line in result.stdout.strip().split("\n")[1:]:
                if "\tdevice" in line:
                    serial = line.split("\t")[0]
                    devices.append({"serial": serial, "type": "android"})
        except FileNotFoundError:
            pass
        
        # 检测鸿蒙设备
        try:
            result = subprocess.run(["hdc", "list", "targets"], capture_output=True, text=True)
            for line in result.stdout.strip().split("\n"):
                if line and not line.startswith("["):
                    devices.append({"serial": line.strip(), "type": "harmony"})
        except FileNotFoundError:
            pass
        
        return devices
    
    def _detect_device_type(self, serial: str) -> Optional[str]:
        """检测设备类型"""
        devices = self.list_devices()
        for d in devices:
            if d["serial"] == serial:
                return d["type"]
        return None
    
    def get_device(self, serial: str) -> Optional[BaseDevice]:
        """获取设备实例"""
        if serial in self._devices:
            return self._devices[serial]
        
        device_type = self._detect_device_type(serial)
        
        if device_type == "android":
            device = AndroidDevice(serial)
        elif device_type == "harmony":
            device = HarmonyDevice(serial)
        else:
            return None
        
        if device.connect():
            self._devices[serial] = device
            return device
        return None
```

**Step 4: 运行测试验证通过**

Run: `cd sinan-core && uv run pytest tests/test_device_manager.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add sinan-core/
git commit -m "feat: 实现设备管理器 DeviceManager"
```

---

## 阶段二：FastAPI 服务层 (Week 2-3)

### Task 6: FastAPI 基础服务

**Files:**
- Create: `sinan-core/src/sinan_core/api/main.py`
- Create: `sinan-core/src/sinan_core/api/routes/__init__.py`
- Create: `sinan-core/src/sinan_core/api/routes/devices.py`
- Create: `sinan-core/tests/test_api.py`

**Step 1: 编写 API 测试**

```python
# sinan-core/tests/test_api.py
import pytest
from fastapi.testclient import TestClient
from sinan_core.api.main import app

client = TestClient(app)

def test_health_check():
    """测试健康检查接口"""
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json()["status"] == "ok"

def test_list_devices():
    """测试设备列表接口"""
    response = client.get("/api/devices")
    assert response.status_code == 200
    assert isinstance(response.json(), list)
```

**Step 2: 运行测试验证失败**

Run: `cd sinan-core && uv run pytest tests/test_api.py -v`
Expected: FAIL

**Step 3: 实现 FastAPI 主应用**

```python
# sinan-core/src/sinan_core/api/main.py
"""FastAPI 主应用"""
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from .routes import devices

app = FastAPI(title="Sinan Core API", version="0.1.0")

# CORS 配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 注册路由
app.include_router(devices.router, prefix="/api")

@app.get("/health")
async def health_check():
    """健康检查"""
    return {"status": "ok"}
```

**Step 4: 实现设备路由**

```python
# sinan-core/src/sinan_core/api/routes/devices.py
"""设备相关 API 路由"""
from fastapi import APIRouter, HTTPException
from sinan_core.drivers.manager import DeviceManager

router = APIRouter(tags=["devices"])
device_manager = DeviceManager()

@router.get("/devices")
async def list_devices():
    """获取设备列表"""
    return device_manager.list_devices()

@router.post("/devices/{serial}/tap")
async def tap(serial: str, x: int, y: int):
    """点击操作"""
    device = device_manager.get_device(serial)
    if not device:
        raise HTTPException(status_code=404, detail="设备未找到")
    
    success = device.tap(x, y)
    return {"success": success}

@router.get("/devices/{serial}/screenshot")
async def screenshot(serial: str):
    """获取截图"""
    device = device_manager.get_device(serial)
    if not device:
        raise HTTPException(status_code=404, detail="设备未找到")
    
    # TODO: 返回 base64 编码的图片
    return {"message": "截图功能待实现"}
```

**Step 5: 创建路由 __init__.py**

```python
# sinan-core/src/sinan_core/api/routes/__init__.py
"""API 路由模块"""
```

**Step 6: 运行测试验证通过**

Run: `cd sinan-core && uv run pytest tests/test_api.py -v`
Expected: PASS

**Step 7: Commit**

```bash
git add sinan-core/
git commit -m "feat: 实现 FastAPI 基础服务和设备 API"
```

---

### Task 7: WebSocket 服务

**Files:**
- Create: `sinan-core/src/sinan_core/api/websocket.py`
- Create: `sinan-core/tests/test_websocket.py`

**Step 1: 编写 WebSocket 测试**

```python
# sinan-core/tests/test_websocket.py
import pytest
from fastapi.testclient import TestClient
from sinan_core.api.main import app

def test_websocket_connection():
    """测试 WebSocket 连接"""
    client = TestClient(app)
    with client.websocket_connect("/ws") as websocket:
        websocket.send_json({"type": "ping"})
        data = websocket.receive_json()
        assert data["type"] == "pong"
```

**Step 2: 运行测试验证失败**

Run: `cd sinan-core && uv run pytest tests/test_websocket.py -v`
Expected: FAIL

**Step 3: 实现 WebSocket 处理器**

```python
# sinan-core/src/sinan_core/api/websocket.py
"""WebSocket 处理器"""
import json
import asyncio
from fastapi import WebSocket, WebSocketDisconnect
from typing import Callable, Any

class ConnectionManager:
    """WebSocket 连接管理器"""
    
    def __init__(self):
        self.active_connections: list[WebSocket] = []
    
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
    
    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
    
    async def send_message(self, websocket: WebSocket, message: dict):
        await websocket.send_json(message)
    
    async def broadcast(self, message: dict):
        for connection in self.active_connections:
            await connection.send_json(message)

manager = ConnectionManager()

async def websocket_endpoint(websocket: WebSocket):
    """WebSocket 端点处理"""
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_json()
            msg_type = data.get("type")
            
            if msg_type == "ping":
                await manager.send_message(websocket, {"type": "pong"})
            
            elif msg_type == "execute":
                # 执行用例
                case_id = data.get("payload", {}).get("caseId")
                await manager.send_message(websocket, {
                    "type": "step_start",
                    "payload": {"caseId": case_id, "stepId": 1}
                })
            
            elif msg_type == "stop":
                case_id = data.get("payload", {}).get("caseId")
                await manager.send_message(websocket, {
                    "type": "stopped",
                    "payload": {"caseId": case_id}
                })
    
    except WebSocketDisconnect:
        manager.disconnect(websocket)
```

**Step 4: 在主应用中注册 WebSocket**

在 `sinan-core/src/sinan_core/api/main.py` 中添加：

```python
from .websocket import websocket_endpoint

@app.websocket("/ws")
async def websocket_route(websocket: WebSocket):
    await websocket_endpoint(websocket)
```

**Step 5: 运行测试验证通过**

Run: `cd sinan-core && uv run pytest tests/test_websocket.py -v`
Expected: PASS

**Step 6: Commit**

```bash
git add sinan-core/
git commit -m "feat: 实现 WebSocket 服务用于实时通信"
```

---

## 阶段三：AI 核心集成 (Week 3-4)

### Task 8: UI 树解析器

**Files:**
- Create: `sinan-core/src/sinan_core/agents/ui_parser.py`
- Create: `sinan-core/tests/test_ui_parser.py`

**Step 1: 编写 UI 树解析测试**

```python
# sinan-core/tests/test_ui_parser.py
import pytest
from sinan_core.agents.ui_parser import UITreeParser

SAMPLE_ANDROID_XML = '''<?xml version="1.0" encoding="UTF-8"?>
<hierarchy>
  <node text="设置" class="android.widget.TextView" bounds="[0,0][100,50]"/>
  <node text="" class="android.widget.Button" content-desc="返回" bounds="[0,50][50,100]"/>
</hierarchy>
'''

def test_parse_android_ui_tree():
    """测试解析 Android UI 树"""
    parser = UITreeParser()
    result = parser.parse_android(SAMPLE_ANDROID_XML)
    
    assert len(result) == 2
    assert result[0]["text"] == "设置"
    assert result[1]["content_desc"] == "返回"

def test_fuzzy_match():
    """测试模糊匹配"""
    parser = UITreeParser()
    elements = [
        {"text": "设置", "bounds": [0, 0, 100, 50]},
        {"text": "显示与亮度", "bounds": [0, 50, 200, 100]},
    ]
    
    matches = parser.fuzzy_match("设置", elements)
    assert len(matches) == 1
    assert matches[0]["text"] == "设置"
```

**Step 2: 运行测试验证失败**

Run: `cd sinan-core && uv run pytest tests/test_ui_parser.py -v`
Expected: FAIL

**Step 3: 实现 UI 树解析器**

```python
# sinan-core/src/sinan_core/agents/ui_parser.py
"""UI 树解析器"""
import re
import xml.etree.ElementTree as ET
from typing import Optional

class UITreeParser:
    """UI 树解析和元素匹配"""
    
    def parse_android(self, xml_content: str) -> list[dict]:
        """解析 Android uiautomator dump 输出"""
        elements = []
        try:
            root = ET.fromstring(xml_content)
            self._traverse_android(root, elements)
        except ET.ParseError:
            pass
        return elements
    
    def _traverse_android(self, node: ET.Element, elements: list):
        """递归遍历 Android UI 树"""
        bounds_str = node.get("bounds", "[0,0][0,0]")
        bounds = self._parse_bounds(bounds_str)
        
        element = {
            "text": node.get("text", ""),
            "class": node.get("class", ""),
            "content_desc": node.get("content-desc", ""),
            "resource_id": node.get("resource-id", ""),
            "bounds": bounds,
            "center": [(bounds[0] + bounds[2]) // 2, (bounds[1] + bounds[3]) // 2],
        }
        
        if element["text"] or element["content_desc"] or element["resource_id"]:
            elements.append(element)
        
        for child in node:
            self._traverse_android(child, elements)
    
    def _parse_bounds(self, bounds_str: str) -> list[int]:
        """解析 bounds 字符串 [x1,y1][x2,y2]"""
        match = re.findall(r'\d+', bounds_str)
        if len(match) == 4:
            return [int(x) for x in match]
        return [0, 0, 0, 0]
    
    def parse_harmony(self, json_content: dict) -> list[dict]:
        """解析鸿蒙 uitest dumpLayout 输出"""
        elements = []
        if isinstance(json_content, dict):
            self._traverse_harmony(json_content, elements)
        return elements
    
    def _traverse_harmony(self, node: dict, elements: list):
        """递归遍历鸿蒙 UI 树"""
        bounds = node.get("bounds", {})
        element = {
            "text": node.get("text", ""),
            "type": node.get("type", ""),
            "id": node.get("id", ""),
            "bounds": [
                bounds.get("left", 0),
                bounds.get("top", 0),
                bounds.get("right", 0),
                bounds.get("bottom", 0),
            ],
        }
        
        if element["text"] or element["id"]:
            element["center"] = [
                (element["bounds"][0] + element["bounds"][2]) // 2,
                (element["bounds"][1] + element["bounds"][3]) // 2,
            ]
            elements.append(element)
        
        for child in node.get("children", []):
            self._traverse_harmony(child, elements)
    
    def fuzzy_match(self, query: str, elements: list[dict]) -> list[dict]:
        """模糊匹配元素"""
        matches = []
        query_lower = query.lower()
        
        for elem in elements:
            text = elem.get("text", "").lower()
            desc = elem.get("content_desc", "").lower()
            res_id = elem.get("resource_id", "").lower()
            
            if query_lower in text or query_lower in desc or query_lower in res_id:
                matches.append(elem)
        
        return matches
```

**Step 4: 运行测试验证通过**

Run: `cd sinan-core && uv run pytest tests/test_ui_parser.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add sinan-core/
git commit -m "feat: 实现 UI 树解析器支持 Android 和鸿蒙"
```

---

### Task 9: 执行决策 Agent

**Files:**
- Create: `sinan-core/src/sinan_core/agents/executor.py`
- Create: `sinan-core/tests/test_executor.py`

**Step 1: 编写执行决策测试**

```python
# sinan-core/tests/test_executor.py
import pytest
from unittest.mock import Mock, patch
from sinan_core.agents.executor import ExecutionAgent, ExecutionStrategy

def test_decide_strategy_ui_tree_match():
    """测试 UI 树直接匹配策略"""
    agent = ExecutionAgent()
    ui_elements = [
        {"text": "设置", "center": [100, 50]},
        {"text": "显示", "center": [100, 100]},
    ]
    
    strategy, target = agent.decide_strategy("点击设置", ui_elements)
    
    assert strategy == ExecutionStrategy.UI_TREE
    assert target["text"] == "设置"

def test_decide_strategy_vision_fallback():
    """测试视觉模型兜底策略"""
    agent = ExecutionAgent()
    ui_elements = [
        {"text": "设置", "center": [100, 50]},
    ]
    
    strategy, target = agent.decide_strategy("点击那个蓝色图标", ui_elements)
    
    assert strategy == ExecutionStrategy.VISION
    assert target is None
```

**Step 2: 运行测试验证失败**

Run: `cd sinan-core && uv run pytest tests/test_executor.py -v`
Expected: FAIL

**Step 3: 实现执行决策 Agent**

```python
# sinan-core/src/sinan_core/agents/executor.py
"""执行决策 Agent"""
from enum import Enum
from typing import Optional, Tuple
from .ui_parser import UITreeParser

class ExecutionStrategy(Enum):
    """执行策略枚举"""
    UI_TREE = "ui_tree"      # UI 树直接匹配
    LLM_SELECT = "llm_select"  # LLM 辅助选择
    VISION = "vision"        # 视觉模型识别

class ExecutionAgent:
    """执行决策 Agent，负责选择最优执行策略"""
    
    def __init__(self):
        self.parser = UITreeParser()
    
    def decide_strategy(
        self, 
        instruction: str, 
        ui_elements: list[dict]
    ) -> Tuple[ExecutionStrategy, Optional[dict]]:
        """
        决定执行策略
        
        Args:
            instruction: 自然语言指令
            ui_elements: UI 树元素列表
        
        Returns:
            (策略类型, 目标元素)
        """
        # 提取指令中的关键词
        keywords = self._extract_keywords(instruction)
        
        # 尝试从 UI 树匹配
        candidates = []
        for keyword in keywords:
            matches = self.parser.fuzzy_match(keyword, ui_elements)
            candidates.extend(matches)
        
        # 去重
        seen = set()
        unique_candidates = []
        for c in candidates:
            key = str(c.get("center", []))
            if key not in seen:
                seen.add(key)
                unique_candidates.append(c)
        
        if len(unique_candidates) == 1:
            # 唯一匹配，直接使用 UI 树
            return ExecutionStrategy.UI_TREE, unique_candidates[0]
        
        if len(unique_candidates) > 1:
            # 多个候选，需要 LLM 辅助选择
            return ExecutionStrategy.LLM_SELECT, unique_candidates
        
        # 没有匹配，使用视觉模型
        return ExecutionStrategy.VISION, None
    
    def _extract_keywords(self, instruction: str) -> list[str]:
        """从指令中提取关键词"""
        # 移除常见动词
        verbs = ["点击", "点", "按", "选择", "打开", "进入", "找到", "tap", "click"]
        text = instruction
        for verb in verbs:
            text = text.replace(verb, " ")
        
        # 分词（简单实现）
        keywords = [w.strip() for w in text.split() if w.strip()]
        
        # 如果没有提取到关键词，使用原始指令
        if not keywords:
            keywords = [instruction]
        
        return keywords
```

**Step 4: 运行测试验证通过**

Run: `cd sinan-core && uv run pytest tests/test_executor.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add sinan-core/
git commit -m "feat: 实现执行决策 Agent 支持分层策略"
```

---

### Task 10: 用例数据模型

**Files:**
- Create: `sinan-core/src/sinan_core/models/case.py`
- Create: `sinan-core/tests/test_case_model.py`

**Step 1: 编写用例模型测试**

```python
# sinan-core/tests/test_case_model.py
import pytest
import json
from sinan_core.models.case import TestCase, TestStep

def test_create_test_case():
    """测试创建测试用例"""
    case = TestCase(
        case_id="tc_001",
        case_name="修改字体大小",
    )
    assert case.case_id == "tc_001"
    assert len(case.steps) == 0

def test_add_step():
    """测试添加步骤"""
    case = TestCase(case_id="tc_001", case_name="测试")
    step = TestStep(
        step_id=1,
        action="tap",
        target_desc="设置图标",
        coordinates=[100, 200],
    )
    case.add_step(step)
    
    assert len(case.steps) == 1
    assert case.steps[0].action == "tap"

def test_case_to_json():
    """测试用例序列化为 JSON"""
    case = TestCase(case_id="tc_001", case_name="测试")
    case.add_step(TestStep(step_id=1, action="tap", target_desc="设置", coordinates=[100, 200]))
    
    json_str = case.to_json()
    data = json.loads(json_str)
    
    assert data["case_id"] == "tc_001"
    assert len(data["steps"]) == 1
```

**Step 2: 运行测试验证失败**

Run: `cd sinan-core && uv run pytest tests/test_case_model.py -v`
Expected: FAIL

**Step 3: 创建 models 目录**

```bash
mkdir -p sinan-core/src/sinan_core/models
touch sinan-core/src/sinan_core/models/__init__.py
```

**Step 4: 实现用例数据模型**

```python
# sinan-core/src/sinan_core/models/case.py
"""测试用例数据模型"""
import json
from dataclasses import dataclass, field, asdict
from datetime import datetime
from typing import Optional

@dataclass
class TestStep:
    """测试步骤"""
    step_id: int
    action: str  # tap, swipe, input, wait
    target_desc: str
    coordinates: list[int] = field(default_factory=list)
    screenshot_ref: Optional[str] = None
    strategy_used: str = "ui_tree"
    duration_ms: int = 0
    
    def to_dict(self) -> dict:
        return asdict(self)

@dataclass
class TestCase:
    """测试用例"""
    case_id: str
    case_name: str
    steps: list[TestStep] = field(default_factory=list)
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())
    status: str = "pending"  # pending, running, passed, failed
    
    def add_step(self, step: TestStep):
        """添加步骤"""
        self.steps.append(step)
    
    def to_dict(self) -> dict:
        return {
            "case_id": self.case_id,
            "case_name": self.case_name,
            "steps": [s.to_dict() for s in self.steps],
            "created_at": self.created_at,
            "status": self.status,
        }
    
    def to_json(self) -> str:
        """序列化为 JSON"""
        return json.dumps(self.to_dict(), ensure_ascii=False, indent=2)
    
    @classmethod
    def from_dict(cls, data: dict) -> "TestCase":
        """从字典创建"""
        steps = [TestStep(**s) for s in data.get("steps", [])]
        return cls(
            case_id=data["case_id"],
            case_name=data["case_name"],
            steps=steps,
            created_at=data.get("created_at", datetime.now().isoformat()),
            status=data.get("status", "pending"),
        )
    
    @classmethod
    def from_json(cls, json_str: str) -> "TestCase":
        """从 JSON 创建"""
        return cls.from_dict(json.loads(json_str))
```

**Step 5: 运行测试验证通过**

Run: `cd sinan-core && uv run pytest tests/test_case_model.py -v`
Expected: PASS

**Step 6: Commit**

```bash
git add sinan-core/
git commit -m "feat: 实现测试用例数据模型"
```

---

### Task 11: 用例执行引擎

**Files:**
- Create: `sinan-core/src/sinan_core/agents/runner.py`
- Create: `sinan-core/tests/test_runner.py`

**Step 1: 编写用例执行测试**

```python
# sinan-core/tests/test_runner.py
import pytest
from unittest.mock import Mock, AsyncMock
from sinan_core.agents.runner import CaseRunner
from sinan_core.models.case import TestCase, TestStep

@pytest.fixture
def mock_device():
    device = Mock()
    device.tap.return_value = True
    device.screenshot.return_value = Mock()  # PIL Image mock
    device.get_ui_tree.return_value = {"raw_xml": "<hierarchy/>"}
    return device

@pytest.mark.asyncio
async def test_run_step(mock_device):
    """测试执行单个步骤"""
    runner = CaseRunner(mock_device)
    step = TestStep(step_id=1, action="tap", target_desc="设置", coordinates=[100, 200])
    
    result = await runner.run_step(step)
    
    assert result["success"] is True
    mock_device.tap.assert_called_once_with(100, 200)

@pytest.mark.asyncio
async def test_run_case(mock_device):
    """测试执行完整用例"""
    runner = CaseRunner(mock_device)
    case = TestCase(case_id="tc_001", case_name="测试")
    case.add_step(TestStep(step_id=1, action="tap", target_desc="设置", coordinates=[100, 200]))
    case.add_step(TestStep(step_id=2, action="tap", target_desc="显示", coordinates=[100, 300]))
    
    results = []
    async for result in runner.run_case(case):
        results.append(result)
    
    assert len(results) == 2
    assert all(r["success"] for r in results)
```

**Step 2: 添加 pytest-asyncio 依赖**

Run: `cd sinan-core && uv add --dev pytest-asyncio`

**Step 3: 运行测试验证失败**

Run: `cd sinan-core && uv run pytest tests/test_runner.py -v`
Expected: FAIL

**Step 4: 实现用例执行引擎**

```python
# sinan-core/src/sinan_core/agents/runner.py
"""用例执行引擎"""
import asyncio
import base64
from io import BytesIO
from typing import AsyncGenerator
from ..drivers.base import BaseDevice
from ..models.case import TestCase, TestStep

class CaseRunner:
    """用例执行器"""
    
    def __init__(self, device: BaseDevice):
        self.device = device
    
    async def run_step(self, step: TestStep) -> dict:
        """执行单个步骤"""
        result = {
            "step_id": step.step_id,
            "action": step.action,
            "success": False,
            "screenshot": None,
            "error": None,
        }
        
        try:
            if step.action == "tap":
                x, y = step.coordinates[0], step.coordinates[1]
                success = self.device.tap(x, y)
                result["success"] = success
            
            elif step.action == "swipe":
                coords = step.coordinates
                success = self.device.swipe(coords[0], coords[1], coords[2], coords[3])
                result["success"] = success
            
            elif step.action == "input":
                success = self.device.input_text(step.target_desc)
                result["success"] = success
            
            elif step.action == "wait":
                await asyncio.sleep(step.duration_ms / 1000)
                result["success"] = True
            
            # 截图
            await asyncio.sleep(0.5)  # 等待 UI 更新
            img = self.device.screenshot()
            if img:
                buffer = BytesIO()
                img.save(buffer, format="PNG")
                result["screenshot"] = base64.b64encode(buffer.getvalue()).decode()
        
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    async def run_case(self, case: TestCase) -> AsyncGenerator[dict, None]:
        """执行完整用例，逐步返回结果"""
        case.status = "running"
        
        for step in case.steps:
            result = await self.run_step(step)
            yield result
            
            if not result["success"]:
                case.status = "failed"
                return
        
        case.status = "passed"
```

**Step 5: 运行测试验证通过**

Run: `cd sinan-core && uv run pytest tests/test_runner.py -v`
Expected: PASS

**Step 6: Commit**

```bash
git add sinan-core/
git commit -m "feat: 实现用例执行引擎 CaseRunner"
```

---

## 阶段四：前端框架 (Week 5-6)

### Task 12: 前端依赖安装

**Files:**
- Modify: `package.json`

**Step 1: 安装 UI 组件库依赖**

```bash
cd /Users/void/code/Sinan
pnpm add zustand @tanstack/react-query
pnpm add -D tailwindcss postcss autoprefixer
pnpm add class-variance-authority clsx tailwind-merge
pnpm add lucide-react
```

**Step 2: 初始化 Tailwind CSS**

```bash
npx tailwindcss init -p
```

**Step 3: 配置 tailwind.config.js**

```javascript
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

**Step 4: 更新 src/index.css**

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

**Step 5: 验证构建**

Run: `pnpm dev`
Expected: 应用正常启动

**Step 6: Commit**

```bash
git add .
git commit -m "feat: 配置 Tailwind CSS 和前端依赖"
```

---

### Task 13: 状态管理 Store

**Files:**
- Create: `src/stores/deviceStore.ts`
- Create: `src/stores/caseStore.ts`

**Step 1: 创建 stores 目录**

```bash
mkdir -p src/stores
```

**Step 2: 实现设备状态 Store**

```typescript
// src/stores/deviceStore.ts
import { create } from 'zustand'

interface Device {
  serial: string
  type: 'android' | 'harmony'
  connected: boolean
}

interface DeviceState {
  devices: Device[]
  selectedDevice: string | null
  setDevices: (devices: Device[]) => void
  selectDevice: (serial: string) => void
}

export const useDeviceStore = create<DeviceState>((set) => ({
  devices: [],
  selectedDevice: null,
  setDevices: (devices) => set({ devices }),
  selectDevice: (serial) => set({ selectedDevice: serial }),
}))
```

**Step 3: 实现用例状态 Store**

```typescript
// src/stores/caseStore.ts
import { create } from 'zustand'

interface TestStep {
  stepId: number
  action: string
  targetDesc: string
  coordinates: number[]
  screenshot?: string
  status: 'pending' | 'running' | 'passed' | 'failed'
}

interface TestCase {
  caseId: string
  caseName: string
  steps: TestStep[]
  status: 'pending' | 'running' | 'passed' | 'failed'
}

interface CaseState {
  cases: TestCase[]
  currentCase: string | null
  addCase: (testCase: TestCase) => void
  updateStep: (caseId: string, stepId: number, update: Partial<TestStep>) => void
  setCurrentCase: (caseId: string) => void
}

export const useCaseStore = create<CaseState>((set) => ({
  cases: [],
  currentCase: null,
  addCase: (testCase) => set((state) => ({ 
    cases: [...state.cases, testCase] 
  })),
  updateStep: (caseId, stepId, update) => set((state) => ({
    cases: state.cases.map(c => 
      c.caseId === caseId 
        ? {
            ...c,
            steps: c.steps.map(s => 
              s.stepId === stepId ? { ...s, ...update } : s
            )
          }
        : c
    )
  })),
  setCurrentCase: (caseId) => set({ currentCase: caseId }),
}))
```

**Step 4: Commit**

```bash
git add src/stores/
git commit -m "feat: 实现 Zustand 状态管理 Store"
```

---

### Task 14: WebSocket 客户端 Hook

**Files:**
- Create: `src/hooks/useWebSocket.ts`

**Step 1: 实现 WebSocket Hook**

```typescript
// src/hooks/useWebSocket.ts
import { useEffect, useRef, useCallback, useState } from 'react'

interface WebSocketMessage {
  type: string
  payload?: Record<string, unknown>
}

interface UseWebSocketOptions {
  url: string
  onMessage?: (message: WebSocketMessage) => void
  reconnectInterval?: number
}

export function useWebSocket({ url, onMessage, reconnectInterval = 3000 }: UseWebSocketOptions) {
  const wsRef = useRef<WebSocket | null>(null)
  const [connected, setConnected] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const connect = useCallback(() => {
    try {
      const ws = new WebSocket(url)
      
      ws.onopen = () => {
        setConnected(true)
        setError(null)
      }
      
      ws.onclose = () => {
        setConnected(false)
        // 自动重连
        setTimeout(connect, reconnectInterval)
      }
      
      ws.onerror = (e) => {
        setError('WebSocket 连接错误')
      }
      
      ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data) as WebSocketMessage
          onMessage?.(message)
        } catch (e) {
          console.error('解析消息失败:', e)
        }
      }
      
      wsRef.current = ws
    } catch (e) {
      setError('无法创建 WebSocket 连接')
    }
  }, [url, onMessage, reconnectInterval])

  const send = useCallback((message: WebSocketMessage) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(message))
    }
  }, [])

  const disconnect = useCallback(() => {
    wsRef.current?.close()
  }, [])

  useEffect(() => {
    connect()
    return () => {
      wsRef.current?.close()
    }
  }, [connect])

  return { connected, error, send, disconnect }
}
```

**Step 2: Commit**

```bash
git add src/hooks/
git commit -m "feat: 实现 WebSocket 客户端 Hook"
```

---

### Task 15: 聊天面板组件

**Files:**
- Create: `src/components/ChatPanel/index.tsx`
- Create: `src/components/ChatPanel/MessageList.tsx`
- Create: `src/components/ChatPanel/InputBox.tsx`

**Step 1: 创建组件目录**

```bash
mkdir -p src/components/ChatPanel
```

**Step 2: 实现消息列表组件**

```typescript
// src/components/ChatPanel/MessageList.tsx
import React from 'react'

interface Message {
  id: string
  role: 'user' | 'assistant'
  content: string
  timestamp: Date
}

interface MessageListProps {
  messages: Message[]
}

export function MessageList({ messages }: MessageListProps) {
  return (
    <div className="flex-1 overflow-y-auto p-4 space-y-4">
      {messages.map((msg) => (
        <div
          key={msg.id}
          className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}
        >
          <div
            className={`max-w-[80%] rounded-lg px-4 py-2 ${
              msg.role === 'user'
                ? 'bg-blue-500 text-white'
                : 'bg-gray-100 text-gray-900'
            }`}
          >
            <p className="whitespace-pre-wrap">{msg.content}</p>
            <span className="text-xs opacity-70">
              {msg.timestamp.toLocaleTimeString()}
            </span>
          </div>
        </div>
      ))}
    </div>
  )
}
```

**Step 3: 实现输入框组件**

```typescript
// src/components/ChatPanel/InputBox.tsx
import React, { useState, KeyboardEvent } from 'react'
import { Send } from 'lucide-react'

interface InputBoxProps {
  onSend: (message: string) => void
  disabled?: boolean
}

export function InputBox({ onSend, disabled }: InputBoxProps) {
  const [input, setInput] = useState('')

  const handleSend = () => {
    if (input.trim() && !disabled) {
      onSend(input.trim())
      setInput('')
    }
  }

  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      handleSend()
    }
  }

  return (
    <div className="border-t p-4">
      <div className="flex items-center gap-2">
        <textarea
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="输入测试指令..."
          className="flex-1 resize-none rounded-lg border p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
          rows={1}
          disabled={disabled}
        />
        <button
          onClick={handleSend}
          disabled={disabled || !input.trim()}
          className="rounded-lg bg-blue-500 p-2 text-white hover:bg-blue-600 disabled:opacity-50"
        >
          <Send size={20} />
        </button>
      </div>
    </div>
  )
}
```

**Step 4: 实现聊天面板主组件**

```typescript
// src/components/ChatPanel/index.tsx
import React, { useState, useCallback } from 'react'
import { MessageList } from './MessageList'
import { InputBox } from './InputBox'

interface Message {
  id: string
  role: 'user' | 'assistant'
  content: string
  timestamp: Date
}

export function ChatPanel() {
  const [messages, setMessages] = useState<Message[]>([])
  const [isLoading, setIsLoading] = useState(false)

  const handleSend = useCallback(async (content: string) => {
    // 添加用户消息
    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content,
      timestamp: new Date(),
    }
    setMessages((prev) => [...prev, userMessage])
    setIsLoading(true)

    // TODO: 调用后端 API
    // 模拟 AI 响应
    setTimeout(() => {
      const aiMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: `收到指令：${content}\n正在分析...`,
        timestamp: new Date(),
      }
      setMessages((prev) => [...prev, aiMessage])
      setIsLoading(false)
    }, 1000)
  }, [])

  return (
    <div className="flex h-full flex-col bg-white">
      <div className="border-b p-4">
        <h2 className="text-lg font-semibold">AI 助手</h2>
      </div>
      <MessageList messages={messages} />
      <InputBox onSend={handleSend} disabled={isLoading} />
    </div>
  )
}
```

**Step 5: Commit**

```bash
git add src/components/ChatPanel/
git commit -m "feat: 实现聊天面板组件"
```

---

### Task 16: 设备选择组件

**Files:**
- Create: `src/components/DeviceSelector/index.tsx`

**Step 1: 创建组件目录**

```bash
mkdir -p src/components/DeviceSelector
```

**Step 2: 实现设备选择器**

```typescript
// src/components/DeviceSelector/index.tsx
import React, { useEffect } from 'react'
import { Smartphone } from 'lucide-react'
import { useDeviceStore } from '../../stores/deviceStore'

const API_BASE = 'http://localhost:8000'

export function DeviceSelector() {
  const { devices, selectedDevice, setDevices, selectDevice } = useDeviceStore()

  useEffect(() => {
    // 获取设备列表
    fetch(`${API_BASE}/api/devices`)
      .then((res) => res.json())
      .then((data) => setDevices(data))
      .catch((err) => console.error('获取设备列表失败:', err))
  }, [setDevices])

  return (
    <div className="p-4 border-b">
      <h3 className="text-sm font-medium text-gray-500 mb-2">选择设备</h3>
      <div className="space-y-2">
        {devices.length === 0 ? (
          <p className="text-sm text-gray-400">未检测到设备</p>
        ) : (
          devices.map((device) => (
            <button
              key={device.serial}
              onClick={() => selectDevice(device.serial)}
              className={`w-full flex items-center gap-2 p-2 rounded-lg border ${
                selectedDevice === device.serial
                  ? 'border-blue-500 bg-blue-50'
                  : 'border-gray-200 hover:bg-gray-50'
              }`}
            >
              <Smartphone size={16} />
              <div className="text-left">
                <p className="text-sm font-medium">{device.serial}</p>
                <p className="text-xs text-gray-500">
                  {device.type === 'android' ? 'Android' : '鸿蒙'}
                </p>
              </div>
            </button>
          ))
        )}
      </div>
    </div>
  )
}
```

**Step 3: Commit**

```bash
git add src/components/DeviceSelector/
git commit -m "feat: 实现设备选择组件"
```

---

### Task 17: 截图节点组件

**Files:**
- Create: `src/components/ScreenshotNode/index.tsx`

**Step 1: 创建组件目录**

```bash
mkdir -p src/components/ScreenshotNode
```

**Step 2: 实现截图节点组件**

```typescript
// src/components/ScreenshotNode/index.tsx
import React from 'react'
import { CheckCircle, XCircle, Loader } from 'lucide-react'

interface ScreenshotNodeProps {
  stepId: number
  action: string
  targetDesc: string
  screenshot?: string
  status: 'pending' | 'running' | 'passed' | 'failed'
}

export function ScreenshotNode({
  stepId,
  action,
  targetDesc,
  screenshot,
  status,
}: ScreenshotNodeProps) {
  const statusIcon = {
    pending: null,
    running: <Loader className="animate-spin text-blue-500" size={16} />,
    passed: <CheckCircle className="text-green-500" size={16} />,
    failed: <XCircle className="text-red-500" size={16} />,
  }

  return (
    <div className="w-48 rounded-lg border bg-white shadow-sm overflow-hidden">
      {/* 截图区域 */}
      <div className="h-32 bg-gray-100 flex items-center justify-center">
        {screenshot ? (
          <img
            src={`data:image/png;base64,${screenshot}`}
            alt={`步骤 ${stepId}`}
            className="w-full h-full object-cover"
          />
        ) : (
          <span className="text-gray-400 text-sm">等待截图</span>
        )}
      </div>
      
      {/* 信息区域 */}
      <div className="p-2">
        <div className="flex items-center justify-between">
          <span className="text-xs font-medium text-gray-500">
            步骤 {stepId}
          </span>
          {statusIcon[status]}
        </div>
        <p className="text-sm font-medium truncate" title={targetDesc}>
          {action}: {targetDesc}
        </p>
      </div>
    </div>
  )
}
```

**Step 3: Commit**

```bash
git add src/components/ScreenshotNode/
git commit -m "feat: 实现截图节点组件"
```

---

### Task 18: 主布局整合

**Files:**
- Modify: `src/App.tsx`
- Modify: `src/App.css`

**Step 1: 更新 App.tsx**

```typescript
// src/App.tsx
import React from 'react'
import { ChatPanel } from './components/ChatPanel'
import { DeviceSelector } from './components/DeviceSelector'
import { ScreenshotNode } from './components/ScreenshotNode'
import { useCaseStore } from './stores/caseStore'
import './App.css'

function App() {
  const { cases, currentCase } = useCaseStore()
  const activeCase = cases.find((c) => c.caseId === currentCase)

  return (
    <div className="h-screen flex bg-gray-50">
      {/* 左侧：画布区域 */}
      <div className="flex-1 p-4 overflow-auto">
        <h1 className="text-2xl font-bold mb-4">司南 (Sinan)</h1>
        
        {/* 用例执行画布 */}
        <div className="bg-white rounded-lg border p-4 min-h-[400px]">
          {activeCase ? (
            <div className="flex flex-wrap gap-4">
              {activeCase.steps.map((step) => (
                <ScreenshotNode
                  key={step.stepId}
                  stepId={step.stepId}
                  action={step.action}
                  targetDesc={step.targetDesc}
                  screenshot={step.screenshot}
                  status={step.status}
                />
              ))}
            </div>
          ) : (
            <div className="flex items-center justify-center h-full text-gray-400">
              <p>选择或创建测试用例开始</p>
            </div>
          )}
        </div>
      </div>

      {/* 右侧：控制面板 */}
      <div className="w-96 border-l bg-white flex flex-col">
        <DeviceSelector />
        <div className="flex-1">
          <ChatPanel />
        </div>
      </div>
    </div>
  )
}

export default App
```

**Step 2: 更新 App.css**

```css
/* src/App.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* 自定义滚动条 */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: #a1a1a1;
}
```

**Step 3: 验证应用**

Run: `pnpm dev`
Expected: 应用正常显示，包含左侧画布和右侧聊天面板

**Step 4: Commit**

```bash
git add src/
git commit -m "feat: 整合主布局，完成 UI 框架"
```

---

## 阶段五：端到端整合 (Week 7-8)

### Task 19: Electron 启动 Python 后端

**Files:**
- Modify: `electron/main.ts`
- Create: `electron/pythonManager.ts`

**Step 1: 实现 Python 进程管理器**

```typescript
// electron/pythonManager.ts
import { spawn, ChildProcess } from 'child_process'
import path from 'path'
import { app } from 'electron'

let pythonProcess: ChildProcess | null = null

export function startPythonBackend(): Promise<void> {
  return new Promise((resolve, reject) => {
    const isDev = process.env.NODE_ENV === 'development'
    
    // Python 项目路径
    const pythonPath = isDev
      ? path.join(app.getAppPath(), '..', 'sinan-core')
      : path.join(process.resourcesPath, 'sinan-core')
    
    // 启动命令
    const command = isDev ? 'uv' : 'python'
    const args = isDev
      ? ['run', 'uvicorn', 'sinan_core.api.main:app', '--host', '127.0.0.1', '--port', '8000']
      : ['-m', 'uvicorn', 'sinan_core.api.main:app', '--host', '127.0.0.1', '--port', '8000']
    
    pythonProcess = spawn(command, args, {
      cwd: pythonPath,
      stdio: ['ignore', 'pipe', 'pipe'],
    })
    
    pythonProcess.stdout?.on('data', (data) => {
      console.log(`[Python] ${data}`)
      if (data.toString().includes('Uvicorn running')) {
        resolve()
      }
    })
    
    pythonProcess.stderr?.on('data', (data) => {
      console.error(`[Python Error] ${data}`)
    })
    
    pythonProcess.on('error', (err) => {
      reject(err)
    })
    
    // 超时处理
    setTimeout(() => {
      resolve() // 即使没有收到启动消息也继续
    }, 5000)
  })
}

export function stopPythonBackend(): void {
  if (pythonProcess) {
    pythonProcess.kill()
    pythonProcess = null
  }
}
```

**Step 2: 更新 electron/main.ts**

在 `electron/main.ts` 中添加：

```typescript
import { startPythonBackend, stopPythonBackend } from './pythonManager'

// 在 app.whenReady() 中启动 Python
app.whenReady().then(async () => {
  try {
    await startPythonBackend()
    console.log('Python 后端已启动')
  } catch (err) {
    console.error('启动 Python 后端失败:', err)
  }
  createWindow()
})

// 在应用退出时停止 Python
app.on('will-quit', () => {
  stopPythonBackend()
})
```

**Step 3: Commit**

```bash
git add electron/
git commit -m "feat: Electron 自动启动和管理 Python 后端"
```

---

### Task 20: 前后端通信整合

**Files:**
- Create: `src/services/api.ts`
- Modify: `src/components/ChatPanel/index.tsx`

**Step 1: 实现 API 服务**

```typescript
// src/services/api.ts
const API_BASE = 'http://localhost:8000'

export interface Device {
  serial: string
  type: 'android' | 'harmony'
}

export interface TestCase {
  caseId: string
  caseName: string
  steps: TestStep[]
}

export interface TestStep {
  stepId: number
  action: string
  targetDesc: string
  coordinates: number[]
}

export const api = {
  // 获取设备列表
  async getDevices(): Promise<Device[]> {
    const res = await fetch(`${API_BASE}/api/devices`)
    return res.json()
  },
  
  // 执行点击
  async tap(serial: string, x: number, y: number): Promise<{ success: boolean }> {
    const res = await fetch(`${API_BASE}/api/devices/${serial}/tap?x=${x}&y=${y}`, {
      method: 'POST',
    })
    return res.json()
  },
  
  // 获取截图
  async screenshot(serial: string): Promise<{ screenshot: string }> {
    const res = await fetch(`${API_BASE}/api/devices/${serial}/screenshot`)
    return res.json()
  },
}
```

**Step 2: 更新聊天面板连接 WebSocket**

```typescript
// src/components/ChatPanel/index.tsx (更新)
import React, { useState, useCallback, useEffect } from 'react'
import { MessageList } from './MessageList'
import { InputBox } from './InputBox'
import { useWebSocket } from '../../hooks/useWebSocket'
import { useCaseStore } from '../../stores/caseStore'
import { useDeviceStore } from '../../stores/deviceStore'

// ... 保持 Message 接口不变 ...

export function ChatPanel() {
  const [messages, setMessages] = useState<Message[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const { updateStep, addCase, setCurrentCase } = useCaseStore()
  const { selectedDevice } = useDeviceStore()

  const handleWebSocketMessage = useCallback((msg: { type: string; payload?: any }) => {
    if (msg.type === 'step_start') {
      const { caseId, stepId, action, target } = msg.payload
      updateStep(caseId, stepId, { status: 'running' })
    } else if (msg.type === 'step_done') {
      const { caseId, stepId, screenshot } = msg.payload
      updateStep(caseId, stepId, { status: 'passed', screenshot })
    } else if (msg.type === 'case_done') {
      setIsLoading(false)
      const aiMessage: Message = {
        id: Date.now().toString(),
        role: 'assistant',
        content: `用例执行完成！结果：${msg.payload.result}`,
        timestamp: new Date(),
      }
      setMessages((prev) => [...prev, aiMessage])
    }
  }, [updateStep])

  const { connected, send } = useWebSocket({
    url: 'ws://localhost:8000/ws',
    onMessage: handleWebSocketMessage,
  })

  const handleSend = useCallback(async (content: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content,
      timestamp: new Date(),
    }
    setMessages((prev) => [...prev, userMessage])
    setIsLoading(true)

    // 发送执行命令
    if (content.startsWith('执行')) {
      send({ type: 'execute', payload: { instruction: content, device: selectedDevice } })
    } else {
      // 模拟 AI 响应
      setTimeout(() => {
        const aiMessage: Message = {
          id: (Date.now() + 1).toString(),
          role: 'assistant',
          content: `收到指令：${content}\n正在分析...`,
          timestamp: new Date(),
        }
        setMessages((prev) => [...prev, aiMessage])
        setIsLoading(false)
      }, 1000)
    }
  }, [send, selectedDevice])

  return (
    <div className="flex h-full flex-col bg-white">
      <div className="border-b p-4 flex items-center justify-between">
        <h2 className="text-lg font-semibold">AI 助手</h2>
        <span className={`text-xs ${connected ? 'text-green-500' : 'text-red-500'}`}>
          {connected ? '已连接' : '未连接'}
        </span>
      </div>
      <MessageList messages={messages} />
      <InputBox onSend={handleSend} disabled={isLoading || !connected} />
    </div>
  )
}
```

**Step 3: Commit**

```bash
git add src/
git commit -m "feat: 整合前后端通信，完成 WebSocket 连接"
```

---

### Task 21: 用例执行 API 完善

**Files:**
- Modify: `sinan-core/src/sinan_core/api/websocket.py`
- Modify: `sinan-core/src/sinan_core/api/routes/devices.py`

**Step 1: 完善 WebSocket 执行逻辑**

```python
# sinan-core/src/sinan_core/api/websocket.py (更新)
"""WebSocket 处理器"""
import asyncio
import base64
from io import BytesIO
from fastapi import WebSocket, WebSocketDisconnect
from ..drivers.manager import DeviceManager
from ..agents.executor import ExecutionAgent, ExecutionStrategy
from ..agents.runner import CaseRunner
from ..models.case import TestCase, TestStep

device_manager = DeviceManager()
execution_agent = ExecutionAgent()

class ConnectionManager:
    def __init__(self):
        self.active_connections: list[WebSocket] = []
    
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
    
    def disconnect(self, websocket: WebSocket):
        if websocket in self.active_connections:
            self.active_connections.remove(websocket)
    
    async def send(self, websocket: WebSocket, message: dict):
        await websocket.send_json(message)

manager = ConnectionManager()

async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_json()
            msg_type = data.get("type")
            payload = data.get("payload", {})
            
            if msg_type == "ping":
                await manager.send(websocket, {"type": "pong"})
            
            elif msg_type == "execute":
                instruction = payload.get("instruction", "")
                device_serial = payload.get("device")
                
                if not device_serial:
                    await manager.send(websocket, {
                        "type": "error",
                        "payload": {"message": "未选择设备"}
                    })
                    continue
                
                device = device_manager.get_device(device_serial)
                if not device:
                    await manager.send(websocket, {
                        "type": "error",
                        "payload": {"message": "设备连接失败"}
                    })
                    continue
                
                # 获取 UI 树
                ui_tree = device.get_ui_tree()
                ui_elements = []  # TODO: 解析 UI 树
                
                # 决策执行策略
                strategy, target = execution_agent.decide_strategy(instruction, ui_elements)
                
                if strategy == ExecutionStrategy.UI_TREE and target:
                    # 直接执行
                    x, y = target["center"]
                    await manager.send(websocket, {
                        "type": "step_start",
                        "payload": {"stepId": 1, "action": "tap", "target": target.get("text", "")}
                    })
                    
                    success = device.tap(x, y)
                    await asyncio.sleep(0.5)
                    
                    # 截图
                    img = device.screenshot()
                    buffer = BytesIO()
                    img.save(buffer, format="PNG")
                    screenshot_b64 = base64.b64encode(buffer.getvalue()).decode()
                    
                    await manager.send(websocket, {
                        "type": "step_done",
                        "payload": {
                            "stepId": 1,
                            "success": success,
                            "screenshot": screenshot_b64
                        }
                    })
                    
                    await manager.send(websocket, {
                        "type": "case_done",
                        "payload": {"result": "pass" if success else "fail"}
                    })
                else:
                    # 需要视觉模型（MVP 阶段暂不实现）
                    await manager.send(websocket, {
                        "type": "error",
                        "payload": {"message": "无法识别目标元素，需要视觉模型支持"}
                    })
            
            elif msg_type == "stop":
                await manager.send(websocket, {
                    "type": "stopped",
                    "payload": {}
                })
    
    except WebSocketDisconnect:
        manager.disconnect(websocket)
```

**Step 2: 添加截图 API**

```python
# sinan-core/src/sinan_core/api/routes/devices.py (更新)
import base64
from io import BytesIO
from fastapi import APIRouter, HTTPException
from fastapi.responses import JSONResponse
from sinan_core.drivers.manager import DeviceManager

router = APIRouter(tags=["devices"])
device_manager = DeviceManager()

@router.get("/devices")
async def list_devices():
    return device_manager.list_devices()

@router.post("/devices/{serial}/tap")
async def tap(serial: str, x: int, y: int):
    device = device_manager.get_device(serial)
    if not device:
        raise HTTPException(status_code=404, detail="设备未找到")
    
    success = device.tap(x, y)
    return {"success": success}

@router.get("/devices/{serial}/screenshot")
async def screenshot(serial: str):
    device = device_manager.get_device(serial)
    if not device:
        raise HTTPException(status_code=404, detail="设备未找到")
    
    try:
        img = device.screenshot()
        buffer = BytesIO()
        img.save(buffer, format="PNG")
        screenshot_b64 = base64.b64encode(buffer.getvalue()).decode()
        return {"screenshot": screenshot_b64}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/devices/{serial}/ui-tree")
async def get_ui_tree(serial: str):
    device = device_manager.get_device(serial)
    if not device:
        raise HTTPException(status_code=404, detail="设备未找到")
    
    return device.get_ui_tree()
```

**Step 3: 运行所有测试**

Run: `cd sinan-core && uv run pytest -v`
Expected: 所有测试通过

**Step 4: Commit**

```bash
git add sinan-core/
git commit -m "feat: 完善用例执行 API 和截图功能"
```

---

### Task 22: 本地用例存储

**Files:**
- Create: `sinan-core/src/sinan_core/storage/case_store.py`
- Create: `sinan-core/src/sinan_core/api/routes/cases.py`

**Step 1: 实现本地用例存储**

```python
# sinan-core/src/sinan_core/storage/case_store.py
"""本地用例存储"""
import json
from pathlib import Path
from typing import Optional
from ..models.case import TestCase

class LocalCaseStore:
    """本地 JSON 文件存储"""
    
    def __init__(self, storage_dir: str = "./cases"):
        self.storage_dir = Path(storage_dir)
        self.storage_dir.mkdir(parents=True, exist_ok=True)
    
    def save(self, case: TestCase) -> str:
        """保存用例"""
        file_path = self.storage_dir / f"{case.case_id}.json"
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(case.to_json())
        return str(file_path)
    
    def load(self, case_id: str) -> Optional[TestCase]:
        """加载用例"""
        file_path = self.storage_dir / f"{case_id}.json"
        if not file_path.exists():
            return None
        
        with open(file_path, "r", encoding="utf-8") as f:
            return TestCase.from_json(f.read())
    
    def list_all(self) -> list[dict]:
        """列出所有用例"""
        cases = []
        for file_path in self.storage_dir.glob("*.json"):
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                    cases.append({
                        "case_id": data["case_id"],
                        "case_name": data["case_name"],
                        "status": data.get("status", "pending"),
                    })
            except Exception:
                continue
        return cases
    
    def delete(self, case_id: str) -> bool:
        """删除用例"""
        file_path = self.storage_dir / f"{case_id}.json"
        if file_path.exists():
            file_path.unlink()
            return True
        return False
```

**Step 2: 创建 storage 目录**

```bash
mkdir -p sinan-core/src/sinan_core/storage
touch sinan-core/src/sinan_core/storage/__init__.py
```

**Step 3: 实现用例 API 路由**

```python
# sinan-core/src/sinan_core/api/routes/cases.py
"""用例管理 API"""
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from sinan_core.storage.case_store import LocalCaseStore
from sinan_core.models.case import TestCase, TestStep

router = APIRouter(tags=["cases"])
case_store = LocalCaseStore()

class CreateCaseRequest(BaseModel):
    case_name: str
    steps: list[dict] = []

@router.get("/cases")
async def list_cases():
    """获取所有用例"""
    return case_store.list_all()

@router.get("/cases/{case_id}")
async def get_case(case_id: str):
    """获取单个用例"""
    case = case_store.load(case_id)
    if not case:
        raise HTTPException(status_code=404, detail="用例不存在")
    return case.to_dict()

@router.post("/cases")
async def create_case(request: CreateCaseRequest):
    """创建用例"""
    import uuid
    case_id = f"tc_{uuid.uuid4().hex[:8]}"
    
    case = TestCase(case_id=case_id, case_name=request.case_name)
    for i, step_data in enumerate(request.steps):
        step = TestStep(
            step_id=i + 1,
            action=step_data.get("action", "tap"),
            target_desc=step_data.get("target_desc", ""),
            coordinates=step_data.get("coordinates", [0, 0]),
        )
        case.add_step(step)
    
    case_store.save(case)
    return {"case_id": case_id, "message": "用例创建成功"}

@router.delete("/cases/{case_id}")
async def delete_case(case_id: str):
    """删除用例"""
    if case_store.delete(case_id):
        return {"message": "用例已删除"}
    raise HTTPException(status_code=404, detail="用例不存在")
```

**Step 4: 在主应用中注册路由**

在 `sinan-core/src/sinan_core/api/main.py` 中添加：

```python
from .routes import cases

app.include_router(cases.router, prefix="/api")
```

**Step 5: Commit**

```bash
git add sinan-core/
git commit -m "feat: 实现本地用例存储和管理 API"
```

---

### Task 23: 最终整合测试

**Step 1: 启动 Python 后端**

```bash
cd sinan-core && uv run uvicorn sinan_core.api.main:app --reload --host 127.0.0.1 --port 8000
```

**Step 2: 启动 Electron 应用**

```bash
pnpm dev
```

**Step 3: 验证功能**

1. 检查设备列表是否正常显示
2. 选择设备后，在聊天框输入指令
3. 验证 WebSocket 连接状态
4. 验证截图节点是否正常显示

**Step 4: 运行所有测试**

```bash
cd sinan-core && uv run pytest -v
```

**Step 5: 最终提交**

```bash
git add .
git commit -m "feat: MVP 阶段完成 - 对话生成用例、执行、画布可视化"
```

---

## 总结

本计划完成了司南 MVP 阶段的核心功能：

1. **设备驱动层**：支持 Android (ADB) 和鸿蒙 (HDC) 双端
2. **FastAPI 服务**：提供 REST API 和 WebSocket 实时通信
3. **AI 核心**：UI 树解析、执行决策 Agent、用例执行引擎
4. **前端框架**：React + Tailwind CSS + Zustand 状态管理
5. **端到端整合**：Electron 管理 Python 后端，前后端 WebSocket 通信

下一阶段（Phase 2）将实现：
- 云端用例同步
- 测试设计 Agent
- 多机并发调度
